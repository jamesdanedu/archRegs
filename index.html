<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Irish BIM Fire Safety Checker</title>
    <!-- Add Web-IFC libraries -->
    <script src="https://unpkg.com/web-ifc@0.0.41/web-ifc-api.js"></script>
    <script src="https://unpkg.com/three-mesh-bvh@0.5.23/build/three-mesh-bvh.js"></script>
    <!-- Three.js and other libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: #333;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        header {
            background: #2c3e50;
            color: white;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-title {
            display: flex;
            align-items: center;
        }
        
        .header-title h1 {
            margin-right: 1rem;
        }
        
        .building-type-selector {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            margin-left: 1rem;
        }
        
        .building-type-selector label {
            margin-right: 0.5rem;
            font-size: 0.9rem;
        }
        
        .building-type-selector select {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }
        
        .building-type-selector select option {
            background: #2c3e50;
            color: white;
        }
        
        .subtype-selector {
            margin-left: 0.5rem;
            display: none;
        }
        
        .subtype-selector.active {
            display: flex;
        }
        
        .header-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        #viewer-container {
            flex: 1;
            position: relative;
        }
        
        #side-panel {
            width: 350px;
            background: #f8f9fa;
            border-left: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
        }
        
        .panel-tabs {
            display: flex;
            border-bottom: 1px solid #dee2e6;
        }
        
        .panel-tab {
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-weight: 500;
            color: #6c757d;
            border-bottom: 2px solid transparent;
        }
        
        .panel-tab.active {
            color: #2c3e50;
            border-bottom-color: #3498db;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            display: none;
        }
        
        .panel-content.active {
            display: block;
        }
        
        #property-panel {
            display: flex;
            flex-direction: column;
        }
        
        #property-content {
            overflow-y: auto;
        }
        
        .property-group {
            margin-bottom: 1rem;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 0.5rem;
        }
        
        .property-group h3 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }
        
        .property-item {
            display: flex;
            margin-bottom: 0.25rem;
        }
        
        .property-name {
            font-weight: 500;
            min-width: 120px;
            color: #495057;
        }
        
        .property-value {
            color: #212529;
        }
        
        .toolbar {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 4px;
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            flex-wrap: wrap;
            max-width: 60%;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            white-space: nowrap;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button.toggle-active {
            background: #e74c3c;
        }
        
        button.toggle-active:hover {
            background: #c0392b;
        }
        
        #file-input {
            display: none;
        }
        
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
        }
        
        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: #2c3e50;
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            display: flex;
            justify-content: space-between;
        }
        
        #no-selection {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #6c757d;
            text-align: center;
            padding: 2rem;
        }
        
        #no-selection svg {
            margin-bottom: 1rem;
            color: #adb5bd;
        }
        
        #no-model {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            color: #6c757d;
            text-align: center;
            padding: 2rem;
        }
        
        #no-model svg {
            margin-bottom: 1rem;
            color: #adb5bd;
        }
        
        #example-button {
            margin-top: 1rem;
        }
        
        .issue-item {
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            border-radius: 4px;
            background: #f8f9fa;
            border-left: 4px solid #6c757d;
        }
        
        .issue-item.critical {
            border-left-color: #e74c3c;
            background: #fef2f0;
        }
        
        .issue-item.major {
            border-left-color: #f39c12;
            background: #fef9e7;
        }
        
        .issue-item.minor {
            border-left-color: #3498db;
            background: #edf7fd;
        }
        
        .issue-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .issue-title {
            font-weight: 500;
            color: #2c3e50;
        }
        
        .issue-severity {
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .issue-severity.critical {
            background: #e74c3c;
            color: white;
        }
        
        .issue-severity.major {
            background: #f39c12;
            color: white;
        }
        
        .issue-severity.minor {
            background: #3498db;
            color: white;
        }
        
        .issue-element {
            font-size: 0.8rem;
            color: #6c757d;
            margin-bottom: 0.5rem;
        }
        
        .issue-description {
            color: #495057;
            margin-bottom: 0.5rem;
        }
        
        .issue-regulation {
            font-size: 0.8rem;
            color: #6c757d;
            font-style: italic;
        }
        
        .issue-actions {
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }
        
        .issue-actions button {
            font-size: 0.8rem;
            padding: 0.3rem 0.6rem;
        }
        
        .measurements-toolbar {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.8);
            border-radius: 4px;
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 5;
            display: none;
        }
        
        .measurements-toolbar.active {
            display: flex;
        }
        
        .filter-controls {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #dee2e6;
        }
        
        .filter-title {
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #2c3e50;
        }
        
        .filter-options {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .filter-option {
            font-size: 0.8rem;
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            background: #e9ecef;
            color: #495057;
            cursor: pointer;
        }
        
        .filter-option.active {
            background: #3498db;
            color: white;
        }
        
        .issue-count {
            display: flex;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #dee2e6;
        }
        
        .count-item {
            flex: 1;
            text-align: center;
            font-size: 0.9rem;
            padding: 0.5rem;
        }
        
        .count-number {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }
        
        .count-label {
            color: #6c757d;
        }
        
        .count-critical .count-number {
            color: #e74c3c;
        }
        
        .count-major .count-number {
            color: #f39c12;
        }
        
        .count-minor .count-number {
            color: #3498db;
        }
        
        .measurement-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            color: #2c3e50;
            font-weight: 500;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            pointer-events: none;
        }
        
        #dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            display: none;
        }
        
        .dialog {
            background: white;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .dialog-header {
            padding: 1rem;
            background: #2c3e50;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .dialog-title {
            font-weight: 500;
            font-size: 1.2rem;
        }
        
        .dialog-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .dialog-content {
            padding: 1rem;
            overflow-y: auto;
            flex: 1;
        }
        
        .dialog-footer {
            padding: 1rem;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        
        .rule-category {
            margin-bottom: 1.5rem;
        }
        
        .rule-category-title {
            font-weight: 500;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: #2c3e50;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .rule-item {
            margin-bottom: 0.5rem;
            padding: 0.75rem;
            border-radius: 4px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .rule-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .rule-title {
            font-weight: 500;
            color: #2c3e50;
        }
        
        .rule-severity {
            font-size: 0.8rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .rule-description {
            color: #495057;
            margin-bottom: 0.5rem;
        }
        
        .rule-regulation {
            font-size: 0.8rem;
            color: #6c757d;
            font-style: italic;
        }
        
        #measurement-info {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255, 255, 255, 0.8);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            font-size: 0.9rem;
            color: #2c3e50;
            display: none;
        }
        
        #measurement-info.active {
            display: block;
        }
        
        .annotation {
            position: absolute;
            width: 30px;
            height: 30px;
            background: red;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            transform: translate(-50%, -50%);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            pointer-events: all;
        }
        
        .annotation.critical {
            background: #e74c3c;
        }
        
        .annotation.major {
            background: #f39c12;
        }
        
        .annotation.minor {
            background: #3498db;
        }
        
        .tooltip {
            position: absolute;
            background: white;
            padding: 0.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 0.8rem;
            max-width: 200px;
            z-index: 100;
            display: none;
        }
        
        .progress-container {
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #dee2e6;
        }
        
        .progress-title {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .progress-label {
            font-weight: 500;
            color: #2c3e50;
        }
        
        .progress-percentage {
            color: #6c757d;
        }
        
        .progress-bar {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-value {
            height: 100%;
            background: #3498db;
            border-radius: 4px;
        }
        
        .color-legend {
            position: absolute;
            bottom: 3rem;
            right: 1rem;
            background: rgba(255, 255, 255, 0.8);
            padding: 0.5rem;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 5;
            font-size: 0.8rem;
            display: none;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
        }
        
        .color-box {
            width: 15px;
            height: 15px;
            margin-right: 0.5rem;
            border-radius: 2px;
        }
        
        .mode-button-group {
            margin-bottom: 0.5rem;
            display: flex;
            gap: 0.5rem;
        }
        
        .mode-button {
            background: #e9ecef;
            color: #212529;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            white-space: nowrap;
        }
        
        .mode-button.active {
            background: #3498db;
            color: white;
        }
        
        #building-info-form {
            margin-bottom: 1rem;
        }
        
        .form-group {
            margin-bottom: 0.75rem;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 0.25rem;
            font-weight: 500;
            color: #2c3e50;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        
        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .rule-tabs {
            display: flex;
            border-bottom: 1px solid #dee2e6;
            margin-bottom: 1rem;
        }
        
        .rule-tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #6c757d;
            border-bottom: 2px solid transparent;
        }
        
        .rule-tab.active {
            color: #2c3e50;
            border-bottom-color: #3498db;
            font-weight: 500;
        }
        
        .rule-content {
            display: none;
        }
        
        .rule-content.active {
            display: block;
        }
        
        .occupancy-calculator {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        /* AI Assistant Styles */
        .assistant-header {
            margin-bottom: 1rem;
        }
        
        .assistant-chat {
            height: 300px;
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: #f8f9fa;
        }
        
        .assistant-input {
            display: flex;
            border-top: 1px solid #dee2e6;
            padding: 0.5rem;
        }
        
        .assistant-input textarea {
            flex: 1;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 0.5rem;
            resize: none;
            height: 40px;
        }
        
        .assistant-input button {
            margin-left: 0.5rem;
        }
        
        .assistant-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .chat-message {
            margin-bottom: 1rem;
            max-width: 85%;
            padding: 0.5rem;
            border-radius: 8px;
        }
        
        .user-message {
            margin-left: auto;
            background: #3498db;
            color: white;
            border-radius: 8px 8px 0 8px;
        }
        
        .assistant-message {
            background: #e9ecef;
            border-radius: 8px 8px 8px 0;
        }
        
        .message-time {
            font-size: 0.7rem;
            color: #6c757d;
            margin-top: 0.25rem;
        }
        
        .user-message .message-time {
            text-align: right;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <header>
        <div class="header-title">
            <h1>Irish BIM Fire Safety Checker</h1>
            <div class="building-type-selector">
                <label for="building-type">Building Type:</label>
                <select id="building-type">
                    <option value="dwelling">Dwelling</option>
                    <option value="office">Office</option>
                    <option value="retail">Retail</option>
                    <option value="assembly">Assembly & Recreation</option>
                    <option value="industrial">Industrial</option>
                    <option value="institutional">Institutional/Healthcare</option>
                    <option value="educational">Educational</option>
                    <option value="other">Other</option>
                </select>
                
                <!-- Dwelling subtypes -->
                <div id="dwelling-subtypes" class="subtype-selector active">
                    <select id="dwelling-subtype">
                        <option value="single_family">Single Family House</option>
                        <option value="multi_family">Multi-Family Dwelling</option>
                        <option value="apartment">Apartment</option>
                    </select>
                </div>
                
                <!-- Office subtypes -->
                <div id="office-subtypes" class="subtype-selector">
                    <select id="office-subtype">
                        <option value="small">Small Office (≤ 100 occupants)</option>
                        <option value="medium">Medium Office (101-500 occupants)</option>
                        <option value="large">Large Office (> 500 occupants)</option>
                    </select>
                </div>
            </div>
        </div>
        <div class="header-actions">
            <button id="load-button">Load IFC Model</button>
            <input type="file" id="file-input" accept=".ifc">
            <button id="run-check">Run Fire Safety Check</button>
            <button id="view-rules">View Rules</button>
        </div>
    </header>
    
    <div class="main-container">
        <div id="viewer-container">
            <div id="no-model">
                <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M8.186 1.113a.5.5 0 0 0-.372 0L1.846 3.5l2.404.961L10.404 2l-2.218-.887zm3.564 1.426L5.596 5 8 5.961 14.154 3.5l-2.404-.961zm3.25 1.7-6.5 2.6v7.922l6.5-2.6V4.24zM7.5 14.762V6.838L1 4.239v7.923l6.5 2.6zM7.443.184a1.5 1.5 0 0 1 1.114 0l7.129 2.852A.5.5 0 0 1 16 3.5v8.662a1 1 0 0 1-.629.928l-7.185 2.874a.5.5 0 0 1-.372 0L.63 13.09a1 1 0 0 1-.63-.928V3.5a.5.5 0 0 1 .314-.464L7.443.184z"/>
                </svg>
                <h2>No IFC Model Loaded</h2>
                <p>Click "Load IFC Model" to upload an IFC file</p>
                <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                    <button id="example-dwelling-button">Load Example Dwelling</button>
                    <button id="example-office-button">Load Example Office</button>
                </div>
            </div>
            <div class="toolbar">
                <div class="mode-button-group">
                    <button id="navigation-mode" class="mode-button active">Navigation</button>
                    <button id="measurement-mode" class="mode-button">Measurement</button>
                    <button id="inspection-mode" class="mode-button">Inspection</button>
                </div>
                <button id="reset-view">Reset View</button>
                <button id="section-plane">Toggle Section</button>
                <button id="show-annotations">Show Issues</button>
                <button id="hide-annotations">Hide Issues</button>
                <button id="highlight-issues">Highlight Issues</button>
                <button id="show-all">Show All Elements</button>
            </div>
            <div class="measurements-toolbar">
                <button id="distance-tool" class="measurement-button">Distance</button>
                <button id="area-tool" class="measurement-button">Area</button>
                <button id="angle-tool" class="measurement-button">Angle</button>
                <button id="clear-measurements">Clear</button>
                <button id="exit-measurement">Exit</button>
            </div>
            <div id="measurement-info"></div>
            <div class="color-legend">
                <div class="color-item">
                    <div class="color-box" style="background: #e74c3c;"></div>
                    <div>Critical Issues</div>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background: #f39c12;"></div>
                    <div>Major Issues</div>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background: #3498db;"></div>
                    <div>Minor Issues</div>
                </div>
                <div class="color-item">
                    <div class="color-box" style="background: #2ecc71;"></div>
                    <div>Compliant</div>
                </div>
            </div>
            <div class="loading-screen" style="display: none;">
                <div class="spinner"></div>
                <p id="loading-status">Loading IFC Model...</p>
            </div>
            <div class="status-bar">
                <div id="element-info">No element selected</div>
                <div id="model-stats"></div>
            </div>
        </div>
        
        <div id="side-panel">
            <div class="panel-tabs">
                <div class="panel-tab active" data-panel="properties">Properties</div>
                <div class="panel-tab" data-panel="issues">Issues</div>
                <div class="panel-tab" data-panel="report">Report</div>
                <div class="panel-tab" data-panel="assistant">AI Assistant</div>
            </div>
            
            <div id="properties-panel" class="panel-content active">
                <div id="no-selection">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
                        <path d="m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"/>
                    </svg>
                    <h2>No Element Selected</h2>
                    <p>Click on an element in the model to view its properties</p>
                </div>
                <div id="property-content" style="display: none;"></div>
            </div>
            
            <div id="issues-panel" class="panel-content">
                <div class="filter-controls">
                    <div class="filter-title">Filter Issues:</div>
                    <div class="filter-options">
                        <div class="filter-option active" data-filter="all">All</div>
                        <div class="filter-option" data-filter="critical">Critical</div>
                        <div class="filter-option" data-filter="major">Major</div>
                        <div class="filter-option" data-filter="minor">Minor</div>
                        <div class="filter-option" data-filter="door">Doors</div>
                        <div class="filter-option" data-filter="wall">Walls</div>
                        <div class="filter-option" data-filter="window">Windows</div>
                        <div class="filter-option" data-filter="stairs">Stairs</div>
                    </div>
                </div>
                
                <div class="issue-count">
                    <div class="count-item count-critical">
                        <div class="count-number" id="critical-count">0</div>
                        <div class="count-label">Critical</div>
                    </div>
                    <div class="count-item count-major">
                        <div class="count-number" id="major-count">0</div>
                        <div class="count-label">Major</div>
                    </div>
                    <div class="count-item count-minor">
                        <div class="count-number" id="minor-count">0</div>
                        <div class="count-label">Minor</div>
                    </div>
                </div>
                
                <div id="issues-list">
                    <!-- Issues will be populated here -->
                </div>
            </div>
            
            <div id="report-panel" class="panel-content">
                <div id="building-info-form">
                    <h3>Building Information</h3>
                    <div class="form-group">
                        <label for="building-name">Building Name</label>
                        <input type="text" id="building-name" value="Example Building">
                    </div>
                    <div class="form-group">
                        <label for="building-address">Building Address</label>
                        <input type="text" id="building-address" value="123 Main Street, Dublin">
                    </div>
                    <div class="form-group">
                        <label for="building-floor-area">Floor Area (m²)</label>
                        <input type="number" id="building-floor-area" value="300">
                    </div>
                    <div class="form-group">
                        <label for="building-height">Building Height (m)</label>
                        <input type="number" id="building-height" value="3">
                    </div>
                    <div class="form-group">
                        <label for="building-occupancy">Maximum Occupancy</label>
                        <input type="number" id="building-occupancy" value="30">
                    </div>
                    
                    <div class="form-actions">
                        <button id="update-building-info">Update Information</button>
                    </div>
                </div>
                
                <div class="occupancy-calculator">
                    <h3>Occupancy Calculator</h3>
                    <div class="form-group">
                        <label for="calc-floor-area">Floor Area (m²)</label>
                        <input type="number" id="calc-floor-area" value="300">
                    </div>
                    <div class="form-group">
                        <label for="occupancy-factor">Occupancy Factor</label>
                        <select id="occupancy-factor">
                            <option value="0.1">Warehouse (0.1 person/m²)</option>
                            <option value="0.2" selected>Office (0.2 person/m²)</option>
                            <option value="0.3">Shop (0.3 person/m²)</option>
                            <option value="0.5">Restaurant (0.5 person/m²)</option>
                            <option value="0.7">Bar (0.7 person/m²)</option>
                            <option value="1.5">Standing Area (1.5 persons/m²)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="calculated-occupancy">Calculated Occupancy</label>
                        <input type="text" id="calculated-occupancy" value="60" readonly>
                    </div>
                    <div class="form-actions">
                        <button id="calculate-occupancy">Calculate</button>
                        <button id="apply-occupancy">Apply to Building</button>
                    </div>
                </div>
                
                <div class="progress-container">
                    <div class="progress-title">
                        <div class="progress-label">Overall Compliance</div>
                        <div class="progress-percentage" id="compliance-percentage">0%</div>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-value" id="compliance-bar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="property-group">
                    <h3>Compliance Summary</h3>
                    <div class="property-item">
                        <div class="property-name">Last Check:</div>
                        <div class="property-value" id="last-check-date">Not checked</div>
                    </div>
                    <div class="property-item">
                        <div class="property-name">Issues Found:</div>
                        <div class="property-value" id="total-issues-count">0</div>
                    </div>
                    <div class="property-item">
                        <div class="property-name">Critical Issues:</div>
                        <div class="property-value" id="report-critical-count">0</div>
                    </div>
                    <div class="property-item">
                        <div class="property-name">Status:</div>
                        <div class="property-value" id="compliance-status">Not checked</div>
                    </div>
                </div>
                
                <div class="property-group">
                    <h3>Category Compliance</h3>
                    <div id="category-progress-container">
                        <!-- Category progress bars will be added here -->
                    </div>
                </div>
                
                <div class="property-group">
                    <h3>Actions</h3>
                    <button id="export-report-pdf">Export Report as PDF</button>
                    <button id="export-report-csv">Export Issues as CSV</button>
                    <button id="export-detailed-pdf">Generate Detailed PDF Report</button>
                </div>
            </div>
            
            <!-- AI Assistant Panel -->
            <div id="assistant-panel" class="panel-content">
                <div class="assistant-header">
                    <h3>AI Fire Safety Assistant</h3>
                    <p>Ask questions about fire safety compliance or get help with your model</p>
                </div>
                
                <div class="assistant-chat">
                    <div id="chat-messages"></div>
                    <div class="assistant-input">
                        <textarea id="user-message" placeholder="Ask about fire safety regulations or how to fix issues..."></textarea>
                        <button id="send-message">Send</button>
                    </div>
                </div>
                
                <div class="assistant-actions">
                    <button id="analyze-model">Analyze Model</button>
                    <button id="suggest-fixes">Suggest Fixes</button>
                    <button id="explain-regulations">Explain Regulations</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="dialog-overlay">
        <div class="dialog">
            <div class="dialog-header">
                <div class="dialog-title">Fire Safety Rules</div>
                <button class="dialog-close">&times;</button>
            </div>
            <div class="dialog-content" id="rules-content">
                <div class="rule-tabs">
                    <div class="rule-tab active" data-ruleset="dwelling">Dwelling</div>
                    <div class="rule-tab" data-ruleset="non-dwelling">Non-Dwelling</div>
                </div>
                <div id="dwelling-rules" class="rule-content active">
                    <!-- Dwelling rules will be displayed here -->
                </div>
                <div id="non-dwelling-rules" class="rule-content">
                    <!-- Non-dwelling rules will be displayed here -->
                </div>
            </div>
            <div class="dialog-footer">
                <button id="close-dialog">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Irish Fire Safety Rule Engine with support for multiple building types
        class FireSafetyRuleEngine {
            constructor() {
                // Define rule categories based on Technical Guidance Document B
                this.ruleCategories = [
                    {
                        id: 'means_of_escape',
                        name: 'Means of Escape',
                        description: 'Rules for safe and effective means of escape in case of fire'
                    },
                    {
                        id: 'internal_fire_spread',
                        name: 'Internal Fire Spread',
                        description: 'Rules to inhibit the spread of fire within the building'
                    },
                    {
                        id: 'external_fire_spread',
                        name: 'External Fire Spread',
                        description: 'Rules to inhibit the spread of fire from one building to another'
                    },
                    {
                        id: 'access_facilities',
                        name: 'Access and Facilities',
                        description: 'Rules for access and facilities for the fire service'
                    }
                ];
                
                // Initialize rule sets for different building types
                this.ruleSets = {
                    dwelling: this.initializeDwellingRules(),
                    office: this.initializeOfficeRules(),
                    retail: this.initializeOfficeRules(), // Using office rules as placeholder
                    assembly: this.initializeOfficeRules(), // Using office rules as placeholder
                    industrial: this.initializeOfficeRules(), // Using office rules as placeholder
                    institutional: this.initializeOfficeRules(), // Using office rules as placeholder
                    educational: this.initializeOfficeRules(), // Using office rules as placeholder
                    other: this.initializeOfficeRules() // Using office rules as placeholder
                };
                
                // Current active rule set
                this.activeRuleSet = 'dwelling';
                
                // Store validation results
                this.validationResults = [];
                this.resultsByCategory = {};
                this.resultsBySeverity = {
                    critical: [],
                    major: [],
                    minor: []
                };
            }
            
            // Initialize rules for dwelling houses based on TGD-B Volume 2
            initializeDwellingRules() {
                return [
                    // Means of Escape Rules for Dwellings
                    {
                        id: 'moe_escape_windows',
                        category: 'means_of_escape',
                        title: 'Escape Windows',
                        description: 'All habitable rooms not on the ground floor should have an escape window with minimum dimensions of 450mm x 450mm and minimum clear opening area of 0.33 sq.m',
                        regulation: 'TGD-B 2006, Volume 2, Section 1.5',
                        severity: 'critical',
                        applicableElements: ['window'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'window') return null;
                            
                            // Check if window is not on ground floor
                            const isGroundFloor = element.position.y < 0.5;
                            if (isGroundFloor) return null;
                            
                            const width = parseInt(element.userData.properties['Width']) || 0;
                            const height = parseInt(element.userData.properties['Height']) || 0;
                            const openingArea = parseFloat(element.userData.properties['Opening Area']) || 0;
                            
                            if (width < 450 || height < 450 || openingArea < 0.33) {
                                return {
                                    ruleId: 'moe_escape_windows',
                                    element: element,
                                    severity: 'critical',
                                    description: `Window does not meet escape window requirements: ${width}mm x ${height}mm, opening area ${openingArea} sq.m (minimum 450mm x 450mm with 0.33 sq.m opening)`,
                                    recommendation: 'Install compliant escape window with minimum 450mm x 450mm dimensions and 0.33 sq.m clear opening'
                                };
                            }
                            return null;
                        }
                    },
                    {
                        id: 'moe_protected_hallway',
                        category: 'means_of_escape',
                        title: 'Protected Hallway',
                        description: 'Hallways serving bedrooms should be protected with fire-resistant construction',
                        regulation: 'TGD-B 2006, Volume 2, Section 1.3.4',
                        severity: 'major',
                        applicableElements: ['wall'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'wall') return null;
                            
                            // Check if wall is in hallway serving bedrooms
                            const isHallwayWall = element.userData.name.includes('Hallway') || 
                                                 element.userData.name.includes('Corridor');
                            
                            if (isHallwayWall) {
                                const rating = parseInt(element.userData.properties['Fire Rating']) || 0;
                                
                                if (rating < 30) {
                                    return {
                                        ruleId: 'moe_protected_hallway',
                                        element: element,
                                        severity: 'major',
                                        description: `Hallway wall has insufficient fire rating (${rating} minutes). Minimum required is 30 minutes`,
                                        recommendation: 'Upgrade hallway wall construction to achieve at least 30 minutes fire resistance'
                                    };
                                }
                            }
                            return null;
                        }
                    },
                    
                    // Internal Fire Spread Rules for Dwellings
                    {
                        id: 'ifs_kitchen_door',
                        category: 'internal_fire_spread',
                        title: 'Kitchen Fire Door',
                        description: 'Door between kitchen and escape route should be a fire door with at least 20 minutes fire resistance',
                        regulation: 'TGD-B 2006, Volume 2, Section 3.1',
                        severity: 'major',
                        applicableElements: ['door'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'door') return null;
                            
                            const isKitchenDoor = element.userData.name.includes('Kitchen');
                            if (isKitchenDoor) {
                                const rating = parseInt(element.userData.properties['Fire Rating']) || 0;
                                
                                if (rating < 20) {
                                    return {
                                        ruleId: 'ifs_kitchen_door',
                                        element: element,
                                        severity: 'major',
                                        description: `Kitchen door has insufficient fire rating (${rating} minutes). Minimum required is 20 minutes`,
                                        recommendation: 'Install a fire door with at least 20 minutes fire resistance'
                                    };
                                }
                            }
                            return null;
                        }
                    },
                    
                    // External Fire Spread Rules for Dwellings
                    {
                        id: 'efs_external_wall',
                        category: 'external_fire_spread',
                        title: 'External Wall Fire Rating',
                        description: 'External walls should have appropriate fire resistance based on distance from boundary',
                        regulation: 'TGD-B 2006, Volume 2, Section 4.1',
                        severity: 'major',
                        applicableElements: ['wall'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'wall') return null;
                            
                            const isExternal = element.userData.properties['External'] === 'Yes';
                            
                            if (isExternal) {
                                const rating = parseInt(element.userData.properties['Fire Rating']) || 0;
                                const distanceToBoundary = parseFloat(element.userData.properties['Distance to Boundary'] || '0');
                                
                                // Simplified check - in reality would vary by distance
                                if (distanceToBoundary < 1 && rating < 60) {
                                    return {
                                        ruleId: 'efs_external_wall',
                                        element: element,
                                        severity: 'major',
                                        description: `External wall too close to boundary (${distanceToBoundary}m) has insufficient fire rating (${rating} minutes)`,
                                        recommendation: 'Upgrade external wall to achieve at least 60 minutes fire resistance'
                                    };
                                }
                            }
                            return null;
                        }
                    },
                    
                    // Access and Facilities Rules for Dwellings
                    {
                        id: 'af_smoke_alarms',
                        category: 'access_facilities',
                        title: 'Smoke Alarms',
                        description: 'Dwellings should have smoke alarms on each floor level',
                        regulation: 'TGD-B 2006, Volume 2, Section 1.5.9',
                        severity: 'critical',
                        applicableElements: ['ceiling'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'ceiling') return null;
                            
                            // Check if there's a smoke alarm on each floor (simplified)
                            const hasSmokeAlarm = element.userData.properties['Smoke Alarm'] === 'Yes';
                            
                            if (!hasSmokeAlarm) {
                                return {
                                    ruleId: 'af_smoke_alarms',
                                    element: element,
                                    severity: 'critical',
                                    description: 'No smoke alarm detected on this floor level',
                                    recommendation: 'Install interconnected smoke alarms on each floor level'
                                };
                            }
                            return null;
                        }
                    }
                ];
            }
            
            // Initialize rules for office buildings based on TGD-B Volume 1
            initializeOfficeRules() {
                return [
                    // Means of Escape Rules for Offices
                    {
                        id: 'moe_travel_distance',
                        category: 'means_of_escape',
                        title: 'Travel Distance',
                        description: 'Maximum travel distance in offices should not exceed 18m in a single direction or 45m where alternative routes are available',
                        regulation: 'TGD-B 2006, Volume 1, Section 1.4.10',
                        severity: 'critical',
                        applicableElements: ['door'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'door') return null;
                            
                            const isExitDoor = element.userData.properties['Emergency Exit'] === 'Yes' || 
                                              element.userData.name.includes('Exit') || 
                                              element.userData.name.includes('Entrance');
                            
                            if (isExitDoor) {
                                // For the prototype, we'll use a simplified check
                                const exitDoors = Object.values(context.elements).filter(el => 
                                    el.userData.type === 'door' && 
                                    (el.userData.properties['Emergency Exit'] === 'Yes' || 
                                     el.userData.name.includes('Exit') || 
                                     el.userData.name.includes('Entrance'))
                                );
                                
                                if (exitDoors.length < 2) {
                                    return {
                                        ruleId: 'moe_travel_distance',
                                        element: exitDoors[0],
                                        severity: 'critical',
                                        description: 'Only one exit door found. Office buildings should have at least two separate exit routes',
                                        recommendation: 'Add another exit door to provide alternative escape routes'
                                    };
                                }
                            }
                            return null;
                        }
                    },
                    {
                        id: 'moe_door_width',
                        category: 'means_of_escape',
                        title: 'Exit Door Width',
                        description: 'Exit doors in offices should have a minimum clear width based on occupancy: 800mm (≤60 persons), 850mm (≤110 persons), 900mm (≤220 persons)',
                        regulation: 'TGD-B 2006, Volume 1, Table 1.4',
                        severity: 'critical',
                        applicableElements: ['door'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'door') return null;
                            
                            const isExitDoor = element.userData.properties['Emergency Exit'] === 'Yes' || 
                                               element.userData.name.includes('Exit') || 
                                               element.userData.name.includes('Entrance');
                            
                            if (isExitDoor) {
                                const width = parseInt(element.userData.properties['Width']) || 0;
                                const occupancy = context.buildingInfo?.occupancy || 60;
                                
                                let requiredWidth = 800;
                                if (occupancy > 220) requiredWidth = 1100;
                                else if (occupancy > 110) requiredWidth = 900;
                                else if (occupancy > 60) requiredWidth = 850;
                                
                                if (width < requiredWidth) {
                                    return {
                                        ruleId: 'moe_door_width',
                                        element: element,
                                        severity: 'critical',
                                        description: `Exit door width (${width}mm) is less than the required ${requiredWidth}mm for ${occupancy} occupants`,
                                        recommendation: `Increase door width to at least ${requiredWidth}mm`
                                    };
                                }
                            }
                            return null;
                        }
                    },
                    
                    // Internal Fire Spread Rules for Offices
                    {
                        id: 'ifs_compartmentation',
                        category: 'internal_fire_spread',
                        title: 'Fire Compartmentation',
                        description: 'Office floor areas should be divided into fire compartments of maximum 2000 m² if sprinklered, 1000 m² if unsprinklered',
                        regulation: 'TGD-B 2006, Volume 1, Table 3.1',
                        severity: 'major',
                        applicableElements: ['floor'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'floor') return null;
                            
                            const floorArea = context.buildingInfo?.floorArea || 1000;
                            const hasSprinklers = context.buildingInfo?.hasSprinklers || false;
                            
                            const maxCompartmentSize = hasSprinklers ? 2000 : 1000;
                            
                            if (floorArea > maxCompartmentSize) {
                                return {
                                    ruleId: 'ifs_compartmentation',
                                    element: element,
                                    severity: 'major',
                                    description: `Floor area (${floorArea} m²) exceeds maximum compartment size of ${maxCompartmentSize} m²`,
                                    recommendation: hasSprinklers ? 
                                        'Divide floor into separate fire compartments with fire-resistant construction' : 
                                        'Install sprinkler system or divide into smaller compartments'
                                };
                            }
                            return null;
                        }
                    },
                    
                    // External Fire Spread Rules for Offices
                    {
                        id: 'efs_external_wall',
                        category: 'external_fire_spread',
                        title: 'External Wall Fire Protection',
                        description: 'External walls of office buildings should have fire resistance based on height and distance from boundary',
                        regulation: 'TGD-B 2006, Volume 1, Section 4.1',
                        severity: 'major',
                        applicableElements: ['wall'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'wall') return null;
                            
                            const isExternal = element.userData.properties['External'] === 'Yes';
                            
                            if (isExternal) {
                                const rating = parseInt(element.userData.properties['Fire Rating']) || 0;
                                const buildingHeight = context.buildingInfo?.height || 3;
                                
                                // Simplified check - in reality would vary by distance and height
                                const requiredRating = buildingHeight > 18 ? 120 : 60;
                                
                                if (rating < requiredRating) {
                                    return {
                                        ruleId: 'efs_external_wall',
                                        element: element,
                                        severity: 'major',
                                        description: `External wall has insufficient fire rating (${rating} minutes). Required rating is ${requiredRating} minutes for ${buildingHeight}m building height`,
                                        recommendation: `Upgrade external wall to achieve ${requiredRating} minutes fire resistance`
                                    };
                                }
                            }
                            return null;
                        }
                    },
                    
                    // Access and Facilities Rules for Offices
                    {
                        id: 'af_fire_detection',
                        category: 'access_facilities',
                        title: 'Fire Detection and Alarm System',
                        description: 'Office buildings should have appropriate category of fire detection and alarm system',
                        regulation: 'TGD-B 2006, Volume 1, Section 1.9',
                        severity: 'critical',
                        applicableElements: ['ceiling'],
                        validate: (element, context) => {
                            if (element.userData.type !== 'ceiling') return null;
                            
                            const hasDetector = element.userData.properties['Fire Detector'] === 'Yes';
                            
                            if (!hasDetector) {
                                return {
                                    ruleId: 'af_fire_detection',
                                    element: element,
                                    severity: 'critical',
                                    description: 'No fire detection system identified',
                                    recommendation: 'Install L2 category fire detection and alarm system throughout the building'
                                };
                            }
                            return null;
                        }
                    }
                ];
            }
            
            // Set the active rule set based on building type
            setActiveRuleSet(buildingType) {
                if (this.ruleSets[buildingType]) {
                    this.activeRuleSet = buildingType;
                    console.log(`Activated ${buildingType} rule set`);
                    return true;
                }
                return false;
            }
            
            // Get current active rules
            getActiveRules() {
                return this.ruleSets[this.activeRuleSet];
            }
            
            // Get rules by category
            getRulesByCategory(categoryId) {
                return this.getActiveRules().filter(rule => rule.category === categoryId);
            }
            
            // Get all rules
            getAllRules() {
                return this.getActiveRules();
            }
            
            // Validate a single element against applicable rules
            validateElement(element, context) {
                const results = [];
                
                // Get applicable rules for this element type
                const applicableRules = this.getActiveRules().filter(rule => 
                    rule.applicableElements.includes(element.userData.type)
                );
                
                // Run each validation rule
                applicableRules.forEach(rule => {
                    const result = rule.validate(element, context);
                    if (result) {
                        results.push(result);
                    }
                });
                
                return results;
            }
            
            // Validate the entire model
            validateModel(elements, buildingInfo) {
                this.validationResults = [];
                const context = { 
                    elements, 
                    buildingInfo,
                    buildingType: this.activeRuleSet
                };
                
                // For each element in the model
                Object.values(elements).forEach(element => {
                    const elementResults = this.validateElement(element, context);
                    this.validationResults = [...this.validationResults, ...elementResults];
                });
                
                // Group validation results
                this.groupValidationResults();
                
                return this.validationResults;
            }
            
            // Group validation results by category and severity
            groupValidationResults() {
                this.resultsByCategory = {};
                this.resultsBySeverity = {
                    critical: [],
                    major: [],
                    minor: []
                };
                
                // Group by category
                this.ruleCategories.forEach(category => {
                    this.resultsByCategory[category.id] = this.validationResults.filter(result => {
                        const rule = this.getActiveRules().find(r => r.id === result.ruleId);
                        return rule && rule.category === category.id;
                    });
                });
                
                // Group by severity
                this.validationResults.forEach(result => {
                    this.resultsBySeverity[result.severity].push(result);
                });
            }
            
            // Get compliance percentage
            getCompliancePercentage() {
                if (this.validationResults.length === 0) return 100;
                
                // Calculate weight of each severity
                const weights = {
                    critical: 5,
                    major: 3,
                    minor: 1
                };
                
                // Calculate total elements checked
                // In a real application, this would be more sophisticated
                const totalElementsChecked = 20;
                
                // Calculate weighted sum of issues
                let weightedIssues = 0;
                Object.entries(this.resultsBySeverity).forEach(([severity, results]) => {
                    weightedIssues += results.length * weights[severity];
                });
                
                // Calculate maximum possible weighted issues
                const maxWeightedIssues = totalElementsChecked * weights.critical;
                
                // Calculate compliance percentage
                const compliance = Math.max(0, 100 - (weightedIssues / maxWeightedIssues * 100));
                
                return Math.round(compliance);
            }
            
            // Get compliance percentage by category
            getCategoryCompliance(categoryId) {
                const categoryResults = this.resultsByCategory[categoryId] || [];
                
                if (categoryResults.length === 0) return 100;
                
                // Simplified calculation for the prototype
                // In a real application, this would consider the total number of checks per category
                const weights = {
                    critical: 5,
                    major: 3,
                    minor: 1
                };
                
                const categoryRules = this.getRulesByCategory(categoryId);
                const maxChecks = categoryRules.length * 2;
                
                let weightedIssues = 0;
                categoryResults.forEach(result => {
                    weightedIssues += weights[result.severity];
                });
                
                const compliance = Math.max(0, 100 - (weightedIssues / (maxChecks * weights.critical) * 100));
                
                return Math.round(compliance);
            }
            
            // Get compliance status
            getComplianceStatus() {
                const compliancePercentage = this.getCompliancePercentage();
                
                if (this.resultsBySeverity.critical.length > 0) {
                    return 'Non-Compliant';
                } else if (this.resultsBySeverity.major.length > 0) {
                    return 'Partially Compliant';
                } else if (this.resultsBySeverity.minor.length > 0) {
                    return 'Substantially Compliant';
                } else {
                    return 'Fully Compliant';
                }
            }
        }
        
        // AI Fire Safety Assistant class
        class AIFireSafetyAssistant {
            constructor(viewer, ruleEngine) {
                this.viewer = viewer;
                this.ruleEngine = ruleEngine;
                this.chatMessages = document.getElementById('chat-messages');
                this.userMessageInput = document.getElementById('user-message');
                this.sendButton = document.getElementById('send-message');
                this.analyzeButton = document.getElementById('analyze-model');
                this.suggestFixesButton = document.getElementById('suggest-fixes');
                this.explainButton = document.getElementById('explain-regulations');
                
                // Regulations knowledge base
                this.regulations = {
                    'TGD-B': 'Technical Guidance Document B - Fire Safety',
                    'means_of_escape': 'Rules for safe and effective means of escape in case of fire',
                    'internal_fire_spread': 'Rules to inhibit the spread of fire within the building',
                    'external_fire_spread': 'Rules to inhibit the spread of fire from one building to another',
                    'access_facilities': 'Rules for access and facilities for the fire service'
                };
                
                // Common fixes knowledge base
                this.commonFixes = {
                    'moe_escape_windows': 'Increase window dimensions to at least 450mm x 450mm with a clear opening area of 0.33 sq.m',
                    'moe_protected_hallway': 'Upgrade hallway walls to achieve at least 30 minutes fire resistance',
                    'ifs_kitchen_door': 'Install a fire door with at least 20 minutes fire resistance',
                    'efs_external_wall': 'Upgrade external wall construction to achieve appropriate fire resistance based on distance to boundary',
                    'af_smoke_alarms': 'Install interconnected smoke alarms on each floor level',
                    'moe_travel_distance': 'Add additional exit doors to reduce travel distances',
                    'moe_door_width': 'Increase door width according to occupancy requirements',
                    'ifs_compartmentation': 'Divide floor into separate fire compartments with fire-resistant construction or install sprinkler system',
                    'af_fire_detection': 'Install appropriate category of fire detection and alarm system'
                };
                
                // Initialize
                this.setupEventListeners();
                
                // Add welcome message
                this.addMessage("Hello! I'm your AI Fire Safety Assistant. I can help you understand fire safety regulations, analyze your model for compliance issues, and suggest fixes. How can I assist you today?", 'assistant');
            }
            
            setupEventListeners() {
                // Send message when button is clicked
                this.sendButton.addEventListener('click', () => {
                    this.handleUserMessage();
                });
                
                // Send message when Enter is pressed (but not with Shift+Enter)
                this.userMessageInput.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' && !event.shiftKey) {
                        event.preventDefault();
                        this.handleUserMessage();
                    }
                });
                
                // Quick action buttons
                this.analyzeButton.addEventListener('click', () => {
                    this.analyzeModel();
                });
                
                this.suggestFixesButton.addEventListener('click', () => {
                    this.suggestFixes();
                });
                
                this.explainButton.addEventListener('click', () => {
                    this.explainRegulations();
                });
            }
            
            handleUserMessage() {
                const message = this.userMessageInput.value.trim();
                if (message === '') return;
                
                // Add user message to chat
                this.addMessage(message, 'user');
                
                // Clear input
                this.userMessageInput.value = '';
                
                // Process message and generate response
                this.processMessage(message);
            }
            
            processMessage(message) {
                // In a real implementation, this would connect to an AI service
                // For the prototype, we'll use some simple pattern matching
                
                // Convert message to lowercase for easier matching
                const lowerMessage = message.toLowerCase();
                
                // Generate response based on message content
                let response;
                
                if (lowerMessage.includes('hello') || lowerMessage.includes('hi') || lowerMessage.includes('hey')) {
                    response = "Hello! I'm your AI Fire Safety Assistant. How can I help you today?";
                }
                else if (lowerMessage.includes('analyze') || lowerMessage.includes('check') || lowerMessage.includes('assess')) {
                    response = "I'll analyze your model for fire safety compliance issues.";
                    // Add a slight delay before performing the analysis
                    setTimeout(() => this.analyzeModel(), 1000);
                }
                else if (lowerMessage.includes('fix') || lowerMessage.includes('solve') || lowerMessage.includes('resolve')) {
                    response = "I'll suggest ways to fix the issues in your model.";
                    setTimeout(() => this.suggestFixes(), 1000);
                }
                else if (lowerMessage.includes('explain') || lowerMessage.includes('tell me about') || lowerMessage.includes('what is')) {
                    if (lowerMessage.includes('tgd') || lowerMessage.includes('document b') || lowerMessage.includes('guidance')) {
                        response = "Technical Guidance Document B (TGD-B) provides practical guidance for meeting the requirements of Part B of the Building Regulations, which deals with Fire Safety. It is divided into two volumes: Volume 1 for Dwellinghouses and Volume 2 for Buildings Other Than Dwellinghouses.";
                    }
                    else if (lowerMessage.includes('means of escape')) {
                        response = "Means of Escape refers to the provisions made to ensure that, in the event of fire, occupants can reach a place of safety unaided and without being exposed to life-threatening fire or smoke. This includes proper exit routes, sufficient exit widths, appropriate travel distances, and emergency lighting.";
                    }
                    else if (lowerMessage.includes('fire resistance')) {
                        response = "Fire resistance is the ability of a component or construction of a building to satisfy, for a stated period of time, some or all of the appropriate criteria specified in the relevant standard fire test. It's typically measured in minutes (30, 60, 90, 120 minutes) and applies to elements like walls, floors, doors, etc.";
                    }
                    else {
                        response = "I can explain various aspects of fire safety regulations. Could you be more specific about what you'd like to know?";
                    }
                }
                else if (lowerMessage.includes('door') || lowerMessage.includes('exit')) {
                    response = "Fire doors are crucial for compartmentation and safe escape. They should have appropriate fire resistance (typically 30 minutes for dwellings and up to 60 minutes for other buildings), be self-closing, and open in the direction of escape. Exit doors should have sufficient width based on occupancy numbers.";
                }
                else if (lowerMessage.includes('window') || lowerMessage.includes('escape window')) {
                    response = "Escape windows in dwellings should have minimum dimensions of 450mm x 450mm and a minimum clear opening area of 0.33 sq.m. The bottom of the openable area should be not more than 1100mm above the floor.";
                }
                else if (lowerMessage.includes('thank')) {
                    response = "You're welcome! If you have any other questions about fire safety compliance, feel free to ask.";
                }
                else {
                    response = "I'm not sure I understand your question. Could you rephrase it or ask something about fire safety regulations, compliance issues, or how to fix specific problems in your model?";
                }
                
                // Add assistant response with a slight delay to seem more natural
                setTimeout(() => {
                    this.addMessage(response, 'assistant');
                }, 500);
            }
            
            addMessage(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${sender}-message`;
                
                // Message text
                const messageText = document.createElement('div');
                messageText.textContent = text;
                messageDiv.appendChild(messageText);
                
                // Message timestamp
                const timestamp = document.createElement('div');
                timestamp.className = 'message-time';
                const now = new Date();
                timestamp.textContent = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
                messageDiv.appendChild(timestamp);
                
                // Add to chat
                this.chatMessages.appendChild(messageDiv);
                
                // Scroll to bottom
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }
            
            analyzeModel() {
                if (!this.viewer.model) {
                    this.addMessage("No model loaded. Please load a model first.", 'assistant');
                    return;
                }
                
                // Check if validation results exist
                if (!this.ruleEngine.validationResults || this.ruleEngine.validationResults.length === 0) {
                    this.addMessage("Running fire safety check on your model...", 'assistant');
                    
                    // Run the fire safety check
                    this.viewer.runFireSafetyCheck();
                    
                    setTimeout(() => {
                        this.provideAnalysisSummary();
                    }, 1000);
                } else {
                    this.provideAnalysisSummary();
                }
            }
            
            provideAnalysisSummary() {
                const compliancePercentage = this.ruleEngine.getCompliancePercentage();
                const complianceStatus = this.ruleEngine.getComplianceStatus();
                const criticalIssues = this.ruleEngine.resultsBySeverity.critical.length;
                const majorIssues = this.ruleEngine.resultsBySeverity.major.length;
                const minorIssues = this.ruleEngine.resultsBySeverity.minor.length;
                
                let summary = `I've analyzed your ${this.viewer.buildingInfo.buildingType} model and found the following:\n\n`;
                summary += `Overall Compliance: ${compliancePercentage}% (${complianceStatus})\n`;
                summary += `Issues Found: ${this.ruleEngine.validationResults.length} total\n`;
                summary += `- ${criticalIssues} Critical issues\n`;
                summary += `- ${majorIssues} Major issues\n`;
                summary += `- ${minorIssues} Minor issues\n\n`;
                
                if (criticalIssues > 0) {
                    summary += `The most urgent issue to address is: ${this.ruleEngine.resultsBySeverity.critical[0].description}\n\n`;
                }
                
                summary += "Would you like me to suggest specific fixes for these issues?";
                
                this.addMessage(summary, 'assistant');
            }
            
            suggestFixes() {
                if (!this.ruleEngine.validationResults || this.ruleEngine.validationResults.length === 0) {
                    this.addMessage("I need to analyze your model first. Running a fire safety check now...", 'assistant');
                    
                    // Run the fire safety check
                    this.viewer.runFireSafetyCheck();
                    
                    setTimeout(() => {
                        this.provideSuggestedFixes();
                    }, 1000);
                } else {
                    this.provideSuggestedFixes();
                }
            }
            
            provideSuggestedFixes() {
                if (this.ruleEngine.validationResults.length === 0) {
                    this.addMessage("Good news! Your model doesn't have any compliance issues that need fixing.", 'assistant');
                    return;
                }
                
                // Start with critical issues
                let fixes = "Here are my recommended fixes, prioritized by severity:\n\n";
                
                if (this.ruleEngine.resultsBySeverity.critical.length > 0) {
                    fixes += "CRITICAL ISSUES (address immediately):\n";
                    
                    this.ruleEngine.resultsBySeverity.critical.forEach((issue, index) => {
                        fixes += `${index + 1}. ${issue.element.userData.name}: ${issue.description}\n`;
                        fixes += `   FIX: ${issue.recommendation || this.commonFixes[issue.ruleId] || 'Address this compliance issue'}\n\n`;
                    });
                }
                
                if (this.ruleEngine.resultsBySeverity.major.length > 0) {
                    fixes += "MAJOR ISSUES:\n";
                    
                    // Limit to top 3 major issues to avoid overwhelming
                    const majorIssues = this.ruleEngine.resultsBySeverity.major.slice(0, 3);
                    majorIssues.forEach((issue, index) => {
                        fixes += `${index + 1}. ${issue.element.userData.name}: ${issue.description}\n`;
                        fixes += `   FIX: ${issue.recommendation || this.commonFixes[issue.ruleId] || 'Address this compliance issue'}\n\n`;
                    });
                    
                    if (this.ruleEngine.resultsBySeverity.major.length > 3) {
                        fixes += `Plus ${this.ruleEngine.resultsBySeverity.major.length - 3} more major issues...\n\n`;
                    }
                }
                
                fixes += "Would you like more specific guidance on implementing any of these fixes?";
                
                this.addMessage(fixes, 'assistant');
            }
            
            explainRegulations() {
                const buildingType = this.viewer.buildingInfo.buildingType;
                
                let explanation = "Here's an overview of the key fire safety regulations applicable to your ";
                explanation += buildingType === 'dwelling' ? "dwelling:\n\n" : "building:\n\n";
                
                explanation += "Technical Guidance Document B (TGD-B) - Fire Safety:\n";
                
                if (buildingType === 'dwelling') {
                    explanation += "For dwellings, Volume 2 of TGD-B applies, which covers:\n\n";
                    
                    explanation += "1. Means of Escape:\n";
                    explanation += "- Every habitable room in upper floors should have an escape window\n";
                    explanation += "- Escape windows must be at least 450mm x 450mm with 0.33 sq.m opening area\n";
                    explanation += "- Protected hallways should have 30 minutes fire resistance\n";
                    explanation += "- Internal doors should not have locks requiring a key to exit\n\n";
                    
                    explanation += "2. Internal Fire Spread:\n";
                    explanation += "- Kitchen doors leading to escape routes need 20 minutes fire resistance\n";
                    explanation += "- Walls between attached dwellings require 60 minutes fire resistance\n";
                    explanation += "- Stairs should have appropriate fire resistance\n\n";
                    
                    explanation += "3. External Fire Spread:\n";
                    explanation += "- External walls need fire resistance based on distance to boundary\n";
                    explanation += "- Roof coverings need resistance to fire spread based on distance\n\n";
                    
                    explanation += "4. Access and Facilities:\n";
                    explanation += "- Smoke alarms required on each floor level\n";
                    explanation += "- Carbon monoxide detectors where fuel-burning appliances are present\n";
                } else {
                    explanation += "For non-dwelling buildings, Volume 1 of TGD-B applies, which covers:\n\n";
                    
                    explanation += "1. Means of Escape:\n";
                    explanation += "- Maximum travel distances (18m in single direction, 45m with alternatives)\n";
                    explanation += "- Door widths based on occupancy: 800mm (≤60), 850mm (≤110), 900mm (≤220)\n";
                    explanation += "- Protected stairways and corridors with fire-resistant construction\n";
                    explanation += "- Multiple escape routes for higher occupancy\n\n";
                    
                    explanation += "2. Internal Fire Spread:\n";
                    explanation += "- Fire compartmentation limits (1000 sq.m without sprinklers, 2000 sq.m with)\n";
                    explanation += "- Fire doors with appropriate ratings on escape routes\n";
                    explanation += "- Fire stopping at services penetrations\n\n";
                    
                    explanation += "3. External Fire Spread:\n";
                    explanation += "- External wall construction based on building height and boundary distance\n";
                    explanation += "- Limitations on unprotected areas based on boundary distance\n\n";
                    
                    explanation += "4. Access and Facilities:\n";
                    explanation += "- Fire detection and alarm systems (category L1-L5 based on risk)\n";
                    explanation += "- Fire service access requirements\n";
                    explanation += "- Fire hydrants and dry risers for larger buildings\n";
                }
                
                explanation += "Is there a specific aspect of these regulations you'd like me to explain in more detail?";
                
                this.addMessage(explanation, 'assistant');
            }
        }
        
        // Main application
        class IFCViewer {
            constructor() {
                // DOM elements
                this.container = document.getElementById('viewer-container');
                this.sidePanel = document.getElementById('side-panel');
                this.propertyPanel = document.getElementById('properties-panel');
                this.issuesPanel = document.getElementById('issues-panel');
                this.reportPanel = document.getElementById('report-panel');
                this.propertyContent = document.getElementById('property-content');
                this.issuesList = document.getElementById('issues-list');
                this.noSelection = document.getElementById('no-selection');
                this.noModel = document.getElementById('no-model');
                this.loadingScreen = document.querySelector('.loading-screen');
                this.loadingStatus = document.getElementById('loading-status');
                this.modelStats = document.getElementById('model-stats');
                this.elementInfo = document.getElementById('element-info');
                this.measurementInfo = document.getElementById('measurement-info');
                this.measurementsToolbar = document.querySelector('.measurements-toolbar');
                this.dialogOverlay = document.getElementById('dialog-overlay');
                this.rulesContent = document.getElementById('rules-content');
                this.buildingTypeSelect = document.getElementById('building-type');
                this.colorLegend = document.querySelector('.color-legend');
                
                // Three.js components
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.raycaster = null;
                this.mouse = null;
                
                // Model data
                this.model = null;
                this.elements = {};
                this.selectedElement = null;
                this.buildingInfo = {
                    name: 'Example Building',
                    address: '123 Main Street, Dublin',
                    floorArea: 300,
                    height: 3,
                    occupancy: 30,
                    hasSprinklers: false,
                    buildingType: 'dwelling',
                    subtype: 'single_family'
                };
                
                // Section planes
                this.sectionPlane = null;
                this.clippingPlane = null;
                this.sectionPlaneActive = false;
                
                // Measurement tools
                this.measurementMode = false;
                this.activeMeasurementTool = null;
                this.measurementPoints = [];
                this.measurementObjects = [];
                
                // Annotations
                this.annotations = [];
                this.annotationsVisible = false;
                
                // Interaction mode
                this.interactionMode = 'navigation'; // 'navigation', 'measurement', or 'inspection'
                
                // Rule engine
                this.ruleEngine = new FireSafetyRuleEngine();
                
                // Initialize the viewer
                this.initialize();
                this.setupEventListeners();
                
                // Set up building type selectors
                this.setupBuildingTypeSelectors();
                
                // Initialize AI assistant
                this.aiAssistant = new AIFireSafetyAssistant(this, this.ruleEngine);
            }
            
            initialize() {
                console.log("Initializing viewer");
                
                // Create Three.js scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);
                
                // Setup camera
                this.camera = new THREE.PerspectiveCamera(
                    45, 
                    this.container.clientWidth / this.container.clientHeight,
                    0.1,
                    1000
                );
                this.camera.position.z = 15;
                this.camera.position.y = 13;
                this.camera.position.x = 8;
                
                // Setup renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.localClippingEnabled = true;
                this.container.appendChild(this.renderer.domElement);
                
                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                this.scene.add(ambientLight);
                
                // Add directional light
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(10, 15, 10);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // Add hemisphere light for better ambient illumination
                const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x303030, 0.3);
                this.scene.add(hemisphereLight);
                
                // Add grid helper
                const gridHelper = new THREE.GridHelper(50, 50);
                this.scene.add(gridHelper);
                
                // Add axes helper
                const axesHelper = new THREE.AxesHelper(5);
                this.scene.add(axesHelper);
                
                // Setup orbit controls
                if (typeof THREE.OrbitControls === 'function') {
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.screenSpacePanning = true;
                } else {
                    console.error("OrbitControls not found");
                    alert("Error: OrbitControls not available. Navigation will be limited.");
                    this.controls = { update: function() {} };
                }
                
                // Setup raycaster for picking
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                // Start animation loop
                this.animate();
                
                // Handle window resize
                window.addEventListener('resize', this.onWindowResize.bind(this));
                
                // Setup occupancy calculator
                this.setupOccupancyCalculator();
            }
            
            setupBuildingTypeSelectors() {
                // Main building type selector
                this.buildingTypeSelect.addEventListener('change', () => {
                    const buildingType = this.buildingTypeSelect.value;
                    
                    // Update active rule set
                    this.ruleEngine.setActiveRuleSet(buildingType);
                    
                    // Update building info
                    this.buildingInfo.buildingType = buildingType;
                    
                    // Show/hide appropriate subtype selector
                    document.querySelectorAll('.subtype-selector').forEach(selector => {
                        selector.classList.remove('active');
                    });
                    
                    const subtypeSelector = document.getElementById(`${buildingType}-subtypes`);
                    if (subtypeSelector) {
                        subtypeSelector.classList.add('active');
                    }
                });
                
                // Subtype selectors
                document.querySelectorAll('.subtype-selector select').forEach(select => {
                    select.addEventListener('change', () => {
                        const subtype = select.value;
                        this.buildingInfo.subtype = subtype;
                    });
                });
            }
            
            setupOccupancyCalculator() {
                const calculateButton = document.getElementById('calculate-occupancy');
                const applyButton = document.getElementById('apply-occupancy');
                
                // Calculate occupancy based on floor area and factor
                calculateButton.addEventListener('click', () => {
                    const floorArea = parseFloat(document.getElementById('calc-floor-area').value);
                    const factor = parseFloat(document.getElementById('occupancy-factor').value);
                    
                    if (floorArea && factor) {
                        const occupancy = Math.round(floorArea * factor);
                        document.getElementById('calculated-occupancy').value = occupancy;
                    }
                });
                
                // Apply calculated occupancy to building info
                applyButton.addEventListener('click', () => {
                    const occupancy = parseInt(document.getElementById('calculated-occupancy').value);
                    
                    if (occupancy) {
                        this.buildingInfo.occupancy = occupancy;
                        document.getElementById('building-occupancy').value = occupancy;
                    }
                });
                
                // Initialize calculation
                const floorArea = parseFloat(document.getElementById('calc-floor-area').value);
                const factor = parseFloat(document.getElementById('occupancy-factor').value);
                document.getElementById('calculated-occupancy').value = Math.round(floorArea * factor);
            }
            
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.controls.update();
                
                // Update annotations if visible
                if (this.annotationsVisible) {
                    this.updateAnnotationsPositions();
                }
                
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
            }
            
            setupEventListeners() {
                // Load IFC file
                const loadButton = document.getElementById('load-button');
                const fileInput = document.getElementById('file-input');
                
                loadButton.addEventListener('click', () => {
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        this.loadIFCFile(file);
                    }
                });
                
                // Load example buildings
                const exampleDwellingButton = document.getElementById('example-dwelling-button');
                exampleDwellingButton.addEventListener('click', () => {
                    // Set building type to dwelling
                    this.buildingTypeSelect.value = 'dwelling';
                    this.buildingTypeSelect.dispatchEvent(new Event('change'));
                    
                    // Load example dwelling
                    this.loadExampleDwelling();
                });
                
                const exampleOfficeButton = document.getElementById('example-office-button');
                exampleOfficeButton.addEventListener('click', () => {
                    // Set building type to office
                    this.buildingTypeSelect.value = 'office';
                    this.buildingTypeSelect.dispatchEvent(new Event('change'));
                    
                    // Load example office
                    this.loadExampleOffice();
                });
                
                // Reset view
                const resetViewButton = document.getElementById('reset-view');
                resetViewButton.addEventListener('click', this.resetView.bind(this));
                
                // Toggle section plane
                const sectionPlaneButton = document.getElementById('section-plane');
                sectionPlaneButton.addEventListener('click', this.toggleSectionPlane.bind(this));
                
                // Mode buttons
                const navigationModeButton = document.getElementById('navigation-mode');
                navigationModeButton.addEventListener('click', () => this.setInteractionMode('navigation'));
                
                const measurementModeButton = document.getElementById('measurement-mode');
                measurementModeButton.addEventListener('click', () => this.setInteractionMode('measurement'));
                
                const inspectionModeButton = document.getElementById('inspection-mode');
                inspectionModeButton.addEventListener('click', () => this.setInteractionMode('inspection'));
                
                // Measurement tools
                const distanceToolButton = document.getElementById('distance-tool');
                distanceToolButton.addEventListener('click', () => this.setMeasurementTool('distance'));
                
                const areaToolButton = document.getElementById('area-tool');
                areaToolButton.addEventListener('click', () => this.setMeasurementTool('area'));
                
                const angleToolButton = document.getElementById('angle-tool');
                angleToolButton.addEventListener('click', () => this.setMeasurementTool('angle'));
                
                const clearMeasurementsButton = document.getElementById('clear-measurements');
                clearMeasurementsButton.addEventListener('click', this.clearMeasurements.bind(this));
                
                const exitMeasurementButton = document.getElementById('exit-measurement');
                exitMeasurementButton.addEventListener('click', () => this.setInteractionMode('navigation'));
                
                // Show/hide annotations
                const showAnnotationsButton = document.getElementById('show-annotations');
                showAnnotationsButton.addEventListener('click', () => this.toggleAnnotations(true));
                
                const hideAnnotationsButton = document.getElementById('hide-annotations');
                hideAnnotationsButton.addEventListener('click', () => this.toggleAnnotations(false));
                
                // Highlight issues
                const highlightIssuesButton = document.getElementById('highlight-issues');
                highlightIssuesButton.addEventListener('click', this.highlightIssues.bind(this));
                
                // Show all elements
                const showAllButton = document.getElementById('show-all');
                showAllButton.addEventListener('click', this.showAllElements.bind(this));
                
                // Run fire safety check
                const runCheckButton = document.getElementById('run-check');
                runCheckButton.addEventListener('click', this.runFireSafetyCheck.bind(this));
                
                // View rules
                const viewRulesButton = document.getElementById('view-rules');
                viewRulesButton.addEventListener('click', this.showRulesDialog.bind(this));
                
                // Close dialog
                const closeDialogButton = document.getElementById('close-dialog');
                closeDialogButton.addEventListener('click', () => {
                    this.dialogOverlay.style.display = 'none';
                });
                
                const dialogCloseX = document.querySelector('.dialog-close');
                dialogCloseX.addEventListener('click', () => {
                    this.dialogOverlay.style.display = 'none';
                });
                
                // Export reports
                const exportReportPDFButton = document.getElementById('export-report-pdf');
                exportReportPDFButton.addEventListener('click', () => this.exportReport('pdf'));
                
                const exportReportCSVButton = document.getElementById('export-report-csv');
                exportReportCSVButton.addEventListener('click', () => this.exportReport('csv'));
                
                const exportDetailedPDFButton = document.getElementById('export-detailed-pdf');
                exportDetailedPDFButton.addEventListener('click', this.generateDetailedPDFReport.bind(this));
                
                // Tab switching
                const tabButtons = document.querySelectorAll('.panel-tab');
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const panelId = button.getAttribute('data-panel');
                        this.switchPanel(panelId);
                    });
                });
                
                // Rule tab switching
                const ruleTabButtons = document.querySelectorAll('.rule-tab');
                ruleTabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const rulesetId = button.getAttribute('data-ruleset');
                        this.switchRuleSet(rulesetId);
                    });
                });
                
                // Issue filtering
                const filterOptions = document.querySelectorAll('.filter-option');
                filterOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const filter = option.getAttribute('data-filter');
                        this.filterIssues(filter);
                        
                        // Update active state
                        filterOptions.forEach(opt => opt.classList.remove('active'));
                        option.classList.add('active');
                    });
                });
                
                // Building info update
                const updateBuildingInfoButton = document.getElementById('update-building-info');
                updateBuildingInfoButton.addEventListener('click', this.updateBuildingInfo.bind(this));
                
                // Handle mouse events
                this.renderer.domElement.addEventListener('click', this.handleClick.bind(this));
                
                // Switch to AI Assistant panel
                const assistantTab = document.querySelector('.panel-tab[data-panel="assistant"]');
                assistantTab.addEventListener('click', () => {
                    this.switchPanel('assistant');
                });
            }
            
            setInteractionMode(mode) {
                this.interactionMode = mode;
                
                // Update UI
                document.querySelectorAll('.mode-button').forEach(button => {
                    button.classList.remove('active');
                });
                document.getElementById(`${mode}-mode`).classList.add('active');
                
                // Handle specific mode setup
                if (mode === 'navigation') {
                    this.controls.enableRotate = true;
                    this.controls.enablePan = true;
                    this.controls.enableZoom = true;
                    this.measurementsToolbar.classList.remove('active');
                    this.measurementInfo.classList.remove('active');
                    document.body.style.cursor = 'auto';
                    
                    // Clear any active measurements
                    this.clearMeasurements();
                    this.activeMeasurementTool = null;
                } 
                else if (mode === 'measurement') {
                    this.controls.enableRotate = true;
                    this.controls.enablePan = true;
                    this.controls.enableZoom = true;
                    this.measurementsToolbar.classList.add('active');
                    document.body.style.cursor = 'crosshair';
                    
                    // Set default measurement tool
                    this.setMeasurementTool('distance');
                } 
                else if (mode === 'inspection') {
                    this.controls.enableRotate = true;
                    this.controls.enablePan = true;
                    this.controls.enableZoom = true;
                    this.measurementsToolbar.classList.remove('active');
                    this.measurementInfo.classList.remove('active');
                    document.body.style.cursor = 'help';
                    
                    // Show color legend
                    this.colorLegend.style.display = 'block';
                }
            }
            
            handleClick(event) {
                // Get mouse position
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                // Handle based on current interaction mode
                if (this.interactionMode === 'measurement' && this.activeMeasurementTool) {
                    this.handleMeasurementClick();
                } else if (this.interactionMode === 'inspection' || this.interactionMode === 'navigation') {
                    this.pickItem();
                }
            }
            
            loadIFCFile(file) {
                this.showLoading('Loading and parsing IFC file...');
                
                // Clear previous models
                this.clearModel();
                
                // Initialize IFC loader
                const ifcAPI = new WebIFC.IfcAPI();
                ifcAPI.SetWasmPath('https://unpkg.com/web-ifc@0.0.41/');
                
                // Read the IFC file
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        this.loadingStatus.textContent = 'Parsing IFC data...';
                        
                        // Load the IFC model data
                        const data = new Uint8Array(event.target.result);
                        await ifcAPI.Init();
                        const modelID = ifcAPI.OpenModel(data);
                        
                        // Get all the geometry from the IFC file
                        this.loadingStatus.textContent = 'Converting IFC to 3D model...';
                        
                        // Create a new THREE.js model
                        this.model = new THREE.Group();
                        this.model.name = file.name;
                        
                        // Process the spatial structure
                        const spatialStructure = await this.getSpatialStructure(ifcAPI, modelID);
                        
                        // Process all elements by type
                        const elementTypes = [
                            'IFCWALL', 'IFCWALLSTANDARDCASE', 
                            'IFCDOOR', 'IFCWINDOW', 
                            'IFCSLAB', 'IFCSTAIR', 'IFCROOF',
                            'IFCCOLUMN', 'IFCBEAM'
                        ];
                        
                        for (const type of elementTypes) {
                            this.loadingStatus.textContent = `Processing ${type.replace('IFC', '')}s...`;
                            await this.processElements(ifcAPI, modelID, type);
                        }
                        
                        // Analyze building type based on IFC data
                        this.analyzeBuildingType(ifcAPI, modelID);
                        
                        // Close the model to free memory
                        ifcAPI.CloseModel(modelID);
                        
                        // Add the model to the scene
                        this.scene.add(this.model);
                        
                        // Update model stats
                        this.modelStats.textContent = `Model: ${file.name} | Elements: ${Object.keys(this.elements).length}`;
                        
                        // Reset view to show the entire model
                        this.resetView();
                        
                        // Hide no model message
                        this.noModel.style.display = 'none';
                        
                        // Hide loading screen
                        this.hideLoading();
                    } catch (error) {
                        console.error('Error loading IFC file:', error);
                        alert(`Error loading IFC file: ${error.message}`);
                        this.hideLoading();
                    }
                };
                
                reader.onerror = (error) => {
                    console.error('Error reading file:', error);
                    alert('Error reading file');
                    this.hideLoading();
                };
                
                reader.readAsArrayBuffer(file);
            }
            
            // Helper method to get spatial structure
            async getSpatialStructure(ifcAPI, modelID) {
                // Get all the projects
                const projects = await ifcAPI.GetLineIDsWithType(modelID, WebIFC.IFCPROJECT);
                
                if (projects.length === 0) return null;
                
                // Get spatial structure properties
                const projectID = projects[0];
                const buildingInfo = {};
                
                try {
                    const projectProperties = await ifcAPI.GetLine(modelID, projectID);
                    buildingInfo.name = projectProperties.Name?.value || 'Unnamed Project';
                    
                    // Extract site info
                    const sites = await ifcAPI.GetLineIDsWithType(modelID, WebIFC.IFCSITE);
                    if (sites.length > 0) {
                        const siteProperties = await ifcAPI.GetLine(modelID, sites[0]);
                        buildingInfo.address = siteProperties.LandTitleNumber?.value || '';
                    }
                    
                    // Extract building info
                    const buildings = await ifcAPI.GetLineIDsWithType(modelID, WebIFC.IFCBUILDING);
                    if (buildings.length > 0) {
                        const buildingProperties = await ifcAPI.GetLine(modelID, buildings[0]);
                        
                        // Try to determine building type
                        const buildingTypeName = buildingProperties.ObjectType?.value || '';
                        
                        if (buildingTypeName.toLowerCase().includes('dwelling') || 
                            buildingTypeName.toLowerCase().includes('house') || 
                            buildingTypeName.toLowerCase().includes('residential')) {
                            this.buildingInfo.buildingType = 'dwelling';
                            this.buildingTypeSelect.value = 'dwelling';
                            this.buildingTypeSelect.dispatchEvent(new Event('change'));
                        } else if (buildingTypeName.toLowerCase().includes('office')) {
                            this.buildingInfo.buildingType = 'office';
                            this.buildingTypeSelect.value = 'office';
                            this.buildingTypeSelect.dispatchEvent(new Event('change'));
                        } else {
                            // Default to 'other' if type can't be determined
                            this.buildingInfo.buildingType = 'other';
                            this.buildingTypeSelect.value = 'other';
                            this.buildingTypeSelect.dispatchEvent(new Event('change'));
                        }
                        
                        // Update building info form
                        this.buildingInfo.name = buildingProperties.Name?.value || 'Unnamed Building';
                        document.getElementById('building-name').value = this.buildingInfo.name;
                        
                        // Extract quantities if available
                        if (buildingProperties.PropertySets) {
                            for (const propSetRef of buildingProperties.PropertySets) {
                                const propSet = await ifcAPI.GetLine(modelID, propSetRef.value);
                                
                                for (const prop of propSet.HasProperties || []) {
                                    const property = await ifcAPI.GetLine(modelID, prop.value);
                                    
                                    if (property.Name?.value === 'GrossFloorArea' && property.NominalValue) {
                                        this.buildingInfo.floorArea = property.NominalValue.value;
                                        document.getElementById('building-floor-area').value = this.buildingInfo.floorArea;
                                    } else if (property.Name?.value === 'Height' && property.NominalValue) {
                                        this.buildingInfo.height = property.NominalValue.value;
                                        document.getElementById('building-height').value = this.buildingInfo.height;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Update form values
                    document.getElementById('building-address').value = buildingInfo.address || this.buildingInfo.address;
                    
                    return buildingInfo;
                } catch (error) {
                    console.error('Error getting spatial structure:', error);
                    return null;
                }
            }
            
            // Process elements by type
            async processElements(ifcAPI, modelID, elementType) {
                try {
                    const elementIDs = await ifcAPI.GetLineIDsWithType(modelID, WebIFC[elementType]);
                    
                    for (const id of elementIDs) {
                        const props = await ifcAPI.GetLine(modelID, id);
                        const geometry = await ifcAPI.GetGeometry(modelID, id);
                        
                        if (!geometry) continue;
                        
                        // Create a Three.js geometry
                        const threeGeometry = this.convertGeometry(geometry);
                        
                        // Determine material based on element type
                        let material;
                        let elementTypeName = elementType.replace('IFC', '').toLowerCase();
                        
                        switch (elementTypeName) {
                            case 'wall':
                            case 'wallstandardcase':
                                material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                                elementTypeName = 'wall';
                                break;
                            case 'door':
                                material = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
                                break;
                            case 'window':
                                material = new THREE.MeshPhongMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.6 });
                                break;
                            case 'slab':
                                material = new THREE.MeshPhongMaterial({ color: 0x999999 });
                                elementTypeName = 'floor';
                                break;
                            case 'stair':
                                material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
                                elementTypeName = 'stairs';
                                break;
                            case 'roof':
                                material = new THREE.MeshPhongMaterial({ color: 0x8d6e63 });
                                break;
                            case 'column':
                            case 'beam':
                                material = new THREE.MeshPhongMaterial({ color: 0xf5f5f5 });
                                break;
                            default:
                                material = new THREE.MeshPhongMaterial({ color: 0xdddddd });
                        }
                        
                        // Create mesh
                        const mesh = new THREE.Mesh(threeGeometry, material);
                        
                        // Extract element properties
                        const elementProperties = {};
                        
                        // Extract name and add basic properties
                        const name = props.Name?.value || `${elementTypeName}_${id}`;
                        
                        // Add some default properties based on element type
                        switch (elementTypeName) {
                            case 'wall':
                                elementProperties['Thickness'] = '300mm';  // Default value
                                elementProperties['Fire Rating'] = '60 minutes';  // Default value
                                elementProperties['External'] = 'Yes';  // Assumption
                                break;
                            case 'door':
                                elementProperties['Width'] = '900mm';  // Default value
                                elementProperties['Height'] = '2100mm';  // Default value
                                elementProperties['Fire Rating'] = '30 minutes';  // Default value
                                break;
                            case 'window':
                                elementProperties['Width'] = '1200mm';  // Default value
                                elementProperties['Height'] = '1200mm';  // Default value
                                elementProperties['Opening Area'] = '0.5 sq.m';  // Default value
                                break;
                            case 'floor':
                                elementProperties['Thickness'] = '200mm';  // Default value
                                elementProperties['Fire Rating'] = '60 minutes';  // Default value
                                break;
                            case 'stairs':
                                elementProperties['Width'] = '1000mm';  // Default value
                                elementProperties['Fire Rating'] = '30 minutes';  // Default value
                                break;
                        }
                        
                        // Extract additional properties if available
                        if (props.PropertySets) {
                            for (const propSetRef of props.PropertySets) {
                                try {
                                    const propSet = await ifcAPI.GetLine(modelID, propSetRef.value);
                                    
                                    for (const prop of propSet.HasProperties || []) {
                                        try {
                                            const property = await ifcAPI.GetLine(modelID, prop.value);
                                            
                                            // Check if this is a relevant fire safety property
                                            if (property.Name?.value && property.NominalValue) {
                                                let propName = property.Name.value;
                                                let propValue = property.NominalValue.value;
                                                
                                                // Handle some common property names
                                                if (propName.includes('FireRating') || propName.includes('Fire Rating')) {
                                                    propName = 'Fire Rating';
                                                    propValue = `${propValue} minutes`;
                                                } else if (propName.includes('Width') || propName.includes('Width')) {
                                                    propName = 'Width';
                                                    propValue = `${propValue}mm`;
                                                } else if (propName.includes('Height') || propName.includes('Height')) {
                                                    propName = 'Height';
                                                    propValue = `${propValue}mm`;
                                                } else if (propName.includes('External') || propName.includes('IsExternal')) {
                                                    propName = 'External';
                                                    propValue = propValue ? 'Yes' : 'No';
                                                }
                                                
                                                elementProperties[propName] = propValue;
                                            }
                                        } catch (error) {
                                            console.warn('Error processing property:', error);
                                        }
                                    }
                                } catch (error) {
                                    console.warn('Error processing property set:', error);
                                }
                            }
                        }
                        
                        // Add element to the model
                        this.model.add(mesh);
                        this.addElementData(mesh, elementTypeName, name, elementProperties);
                    }
                } catch (error) {
                    console.error(`Error processing ${elementType}:`, error);
                }
            }
            
            // Convert IFC geometry to Three.js geometry
            convertGeometry(ifcGeometry) {
                const vertices = [];
                const indices = [];
                
                // Process each coordinate
                for (let i = 0; i < ifcGeometry.GetVertexDataSize(); i += 6) {
                    vertices.push(
                        ifcGeometry.GetVertexData()[i],
                        ifcGeometry.GetVertexData()[i+1],
                        ifcGeometry.GetVertexData()[i+2]
                    );
                }
                
                // Process indices
                for (let i = 0; i < ifcGeometry.GetIndexDataSize(); i++) {
                    indices.push(ifcGeometry.GetIndexData()[i]);
                }
                
                // Create Three.js BufferGeometry
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                return geometry;
            }
            
            // Analyze building type based on IFC data
            analyzeBuildingType(ifcAPI, modelID) {
                // This function would analyze the IFC data to determine the building type
                // For now, we'll use a simple heuristic based on the number of doors and windows
                
                const doorCount = Object.values(this.elements).filter(el => el.userData.type === 'door').length;
                const windowCount = Object.values(this.elements).filter(el => el.userData.type === 'window').length;
                const floorCount = Object.values(this.elements).filter(el => el.userData.type === 'floor').length;
                
                // Estimate building type
                if (doorCount <= 5 && windowCount <= 10 && floorCount <= 2) {
                    // Likely a dwelling
                    this.buildingInfo.buildingType = 'dwelling';
                    this.buildingTypeSelect.value = 'dwelling';
                } else if (doorCount > 10 && windowCount > 20) {
                    // Likely a large office or commercial building
                    this.buildingInfo.buildingType = 'office';
                    this.buildingTypeSelect.value = 'office';
                } else {
                    // Default to other
                    this.buildingInfo.buildingType = 'other';
                    this.buildingTypeSelect.value = 'other';
                }
                
                // Update rule engine
                this.buildingTypeSelect.dispatchEvent(new Event('change'));
            }
            
            loadExampleDwelling() {
                this.showLoading('Creating example dwelling...');
                
                // Clear previous models
                this.clearModel();
                
                // Set building type
                this.buildingTypeSelect.value = 'dwelling';
                this.buildingTypeSelect.dispatchEvent(new Event('change'));
                
                // Update building info
                this.buildingInfo = {
                    name: 'Example Dwelling',
                    address: '42 Residential Lane, Dublin',
                    floorArea: 150,
                    height: 6,
                    occupancy: 4,
                    hasSprinklers: false,
                    buildingType: 'dwelling',
                    subtype: 'single_family'
                };
                
                // Update form values
                document.getElementById('building-name').value = this.buildingInfo.name;
                document.getElementById('building-address').value = this.buildingInfo.address;
                document.getElementById('building-floor-area').value = this.buildingInfo.floorArea;
                document.getElementById('building-height').value = this.buildingInfo.height;
                document.getElementById('building-occupancy').value = this.buildingInfo.occupancy;
                
                // Create example dwelling model
                this.model = new THREE.Group();
                this.model.name = "Example Dwelling";
                
                // Define materials
                const materials = {
                    wall: new THREE.MeshPhongMaterial({ color: 0xcccccc }),
                    floor: new THREE.MeshPhongMaterial({ color: 0x999999 }),
                    ceiling: new THREE.MeshPhongMaterial({ color: 0xdddddd }),
                    door: new THREE.MeshPhongMaterial({ color: 0x8b4513 }),
                    window: new THREE.MeshPhongMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.6 }),
                    stairs: new THREE.MeshPhongMaterial({ color: 0xaaaaaa }),
                    roof: new THREE.MeshPhongMaterial({ color: 0x8d6e63 })
                };
                
                // House dimensions
                const houseWidth = 10;
                const houseDepth = 8;
                const floorHeight = 3;
                const wallThickness = 0.2;
                
                // Create ground floor
                const groundFloorGeometry = new THREE.BoxGeometry(houseWidth, 0.2, houseDepth);
                const groundFloor = new THREE.Mesh(groundFloorGeometry, materials.floor);
                groundFloor.position.y = 0;
                this.model.add(groundFloor);
                this.addElementData(groundFloor, 'floor', 'Floor_Ground', {
                    'Material': 'Concrete',
                    'Thickness': '200mm',
                    'Fire Rating': '60 minutes',
                    'Level': 'Ground Floor',
                    'Floor Area': '80 sq.m'
                });
                
                // Create first floor
                const firstFloorGeometry = new THREE.BoxGeometry(houseWidth, 0.2, houseDepth);
                const firstFloor = new THREE.Mesh(firstFloorGeometry, materials.floor);
                firstFloor.position.y = floorHeight;
                this.model.add(firstFloor);
                this.addElementData(firstFloor, 'floor', 'Floor_First', {
                    'Material': 'Timber Joists + Floorboards',
                    'Thickness': '220mm',
                    'Fire Rating': '30 minutes',
                    'Level': 'First Floor',
                    'Floor Area': '80 sq.m'
                });
                
                // Create ground floor ceiling
                const groundCeilingGeometry = new THREE.BoxGeometry(houseWidth, 0.1, houseDepth);
                const groundCeiling = new THREE.Mesh(groundCeilingGeometry, materials.ceiling);
                groundCeiling.position.y = floorHeight - 0.1;
                this.model.add(groundCeiling);
                this.addElementData(groundCeiling, 'ceiling', 'Ceiling_Ground', {
                    'Material': 'Plasterboard',
                    'Thickness': '12.5mm',
                    'Fire Rating': '30 minutes',
                    'Level': 'Ground Floor',
                    'Smoke Alarm': 'Yes',
                    'Emergency Lighting': 'No'
                });
                
                // Create first floor ceiling
                const firstCeilingGeometry = new THREE.BoxGeometry(houseWidth, 0.1, houseDepth);
                const firstCeiling = new THREE.Mesh(firstCeilingGeometry, materials.ceiling);
                firstCeiling.position.y = floorHeight * 2 - 0.1;
                this.model.add(firstCeiling);
                this.addElementData(firstCeiling, 'ceiling', 'Ceiling_First', {
                    'Material': 'Plasterboard',
                    'Thickness': '12.5mm',
                    'Fire Rating': '30 minutes',
                    'Level': 'First Floor',
                    'Smoke Alarm': 'No', // Non-compliant
                    'Emergency Lighting': 'No'
                });
                
                // Create external walls - ground floor
                // Front wall
                const frontWallGroundGeometry = new THREE.BoxGeometry(houseWidth, floorHeight, wallThickness);
                const frontWallGround = new THREE.Mesh(frontWallGroundGeometry, materials.wall);
                frontWallGround.position.set(0, floorHeight/2, houseDepth/2);
                this.model.add(frontWallGround);
                this.addElementData(frontWallGround, 'wall', 'Wall_Front_Ground', {
                    'Material': 'Brick + Block Cavity',
                    'Thickness': '300mm',
                    'Fire Rating': '60 minutes',
                    'External': 'Yes',
                    'Distance to Boundary': '5m',
                    'Level': 'Ground Floor'
                });
                
                // Back wall
                const backWallGroundGeometry = new THREE.BoxGeometry(houseWidth, floorHeight, wallThickness);
                const backWallGround = new THREE.Mesh(backWallGroundGeometry, materials.wall);
                backWallGround.position.set(0, floorHeight/2, -houseDepth/2);
                this.model.add(backWallGround);
                this.addElementData(backWallGround, 'wall', 'Wall_Back_Ground', {
                    'Material': 'Brick + Block Cavity',
                    'Thickness': '300mm',
                    'Fire Rating': '60 minutes',
                    'External': 'Yes',
                    'Distance to Boundary': '10m',
                    'Level': 'Ground Floor'
                });
                
                // Left wall
const leftWallGroundGeometry = new THREE.BoxGeometry(wallThickness, floorHeight, houseDepth);
const leftWallGround = new THREE.Mesh(leftWallGroundGeometry, materials.wall);
leftWallGround.position.set(-houseWidth/2, floorHeight/2, 0);
this.model.add(leftWallGround);
this.addElementData(leftWallGround, 'wall', 'Wall_Left_Ground', {
    'Material': 'Brick + Block Cavity',
    'Thickness': '300mm',
    'Fire Rating': '60 minutes',
    'External': 'Yes',
    'Distance to Boundary': '3m',
    'Level': 'Ground Floor'
});

// Right wall
const rightWallGroundGeometry = new THREE.BoxGeometry(wallThickness, floorHeight, houseDepth);
const rightWallGround = new THREE.Mesh(rightWallGroundGeometry, materials.wall);
rightWallGround.position.set(houseWidth/2, floorHeight/2, 0);
this.model.add(rightWallGround);
this.addElementData(rightWallGround, 'wall', 'Wall_Right_Ground', {
    'Material': 'Brick + Block Cavity',
    'Thickness': '300mm',
    'Fire Rating': '60 minutes',
    'External': 'Yes',
    'Distance to Boundary': '0.5m', // Close to boundary, needs high fire rating
    'Level': 'Ground Floor'
});

// Create external walls - first floor
// Front wall
const frontWallFirstGeometry = new THREE.BoxGeometry(houseWidth, floorHeight, wallThickness);
const frontWallFirst = new THREE.Mesh(frontWallFirstGeometry, materials.wall);
frontWallFirst.position.set(0, floorHeight + floorHeight/2, houseDepth/2);
this.model.add(frontWallFirst);
this.addElementData(frontWallFirst, 'wall', 'Wall_Front_First', {
    'Material': 'Brick + Block Cavity',
    'Thickness': '300mm',
    'Fire Rating': '60 minutes',
    'External': 'Yes',
    'Distance to Boundary': '5m',
    'Level': 'First Floor'
});

// Back wall
const backWallFirstGeometry = new THREE.BoxGeometry(houseWidth, floorHeight, wallThickness);
const backWallFirst = new THREE.Mesh(backWallFirstGeometry, materials.wall);
backWallFirst.position.set(0, floorHeight + floorHeight/2, -houseDepth/2);
this.model.add(backWallFirst);
this.addElementData(backWallFirst, 'wall', 'Wall_Back_First', {
    'Material': 'Brick + Block Cavity',
    'Thickness': '300mm',
    'Fire Rating': '60 minutes',
    'External': 'Yes',
    'Distance to Boundary': '10m',
    'Level': 'First Floor'
});

// Left wall
const leftWallFirstGeometry = new THREE.BoxGeometry(wallThickness, floorHeight, houseDepth);
const leftWallFirst = new THREE.Mesh(leftWallFirstGeometry, materials.wall);
leftWallFirst.position.set(-houseWidth/2, floorHeight + floorHeight/2, 0);
this.model.add(leftWallFirst);
this.addElementData(leftWallFirst, 'wall', 'Wall_Left_First', {
    'Material': 'Brick + Block Cavity',
    'Thickness': '300mm',
    'Fire Rating': '60 minutes',
    'External': 'Yes',
    'Distance to Boundary': '3m',
    'Level': 'First Floor'
});

// Right wall
const rightWallFirstGeometry = new THREE.BoxGeometry(wallThickness, floorHeight, houseDepth);
const rightWallFirst = new THREE.Mesh(rightWallFirstGeometry, materials.wall);
rightWallFirst.position.set(houseWidth/2, floorHeight + floorHeight/2, 0);
this.model.add(rightWallFirst);
this.addElementData(rightWallFirst, 'wall', 'Wall_Right_First', {
    'Material': 'Brick + Block Cavity',
    'Thickness': '300mm',
    'Fire Rating': '60 minutes',
    'External': 'Yes',
    'Distance to Boundary': '0.5m',
    'Level': 'First Floor'
});

// Create internal walls - ground floor
// Kitchen-living dividing wall
const kitchenWallGeometry = new THREE.BoxGeometry(houseWidth/2, floorHeight, wallThickness);
const kitchenWall = new THREE.Mesh(kitchenWallGeometry, materials.wall);
kitchenWall.position.set(-houseWidth/4, floorHeight/2, 0);
this.model.add(kitchenWall);
this.addElementData(kitchenWall, 'wall', 'Wall_Kitchen_Divider', {
    'Material': 'Blockwork',
    'Thickness': '100mm',
    'Fire Rating': '30 minutes',
    'External': 'No',
    'Level': 'Ground Floor',
    'Purpose': 'Room Divider'
});

// Hallway wall
const hallwayWallGeometry = new THREE.BoxGeometry(wallThickness, floorHeight, houseDepth/2);
const hallwayWall = new THREE.Mesh(hallwayWallGeometry, materials.wall);
hallwayWall.position.set(houseWidth/4, floorHeight/2, houseDepth/4);
this.model.add(hallwayWall);
this.addElementData(hallwayWall, 'wall', 'Wall_Hallway', {
    'Material': 'Studwork + Plasterboard',
    'Thickness': '100mm',
    'Fire Rating': '15 minutes', // Non-compliant
    'External': 'No',
    'Level': 'Ground Floor',
    'Purpose': 'Hallway'
});

// Doors - ground floor
// Main entrance door
const entranceDoorGeometry = new THREE.BoxGeometry(1, 2.1, 0.05);
const entranceDoor = new THREE.Mesh(entranceDoorGeometry, materials.door);
entranceDoor.position.set(0, floorHeight/2 - 0.45, houseDepth/2 - wallThickness/2);
this.model.add(entranceDoor);
this.addElementData(entranceDoor, 'door', 'Door_Main_Entrance', {
    'Material': 'Solid Wood',
    'Width': '1000mm',
    'Height': '2100mm',
    'Fire Rating': '30 minutes',
    'Self-Closing': 'No',
    'Direction': 'Inward',
    'Level': 'Ground Floor'
});

// Kitchen door
const kitchenDoorGeometry = new THREE.BoxGeometry(0.8, 2.1, 0.05);
const kitchenDoor = new THREE.Mesh(kitchenDoorGeometry, materials.door);
kitchenDoor.position.set(-houseWidth/4, floorHeight/2 - 0.45, -1);
this.model.add(kitchenDoor);
this.addElementData(kitchenDoor, 'door', 'Door_Kitchen', {
    'Material': 'Hollow Core',
    'Width': '800mm',
    'Height': '2100mm',
    'Fire Rating': '0 minutes', // Non-compliant
    'Self-Closing': 'No',
    'Direction': 'Outward',
    'Level': 'Ground Floor'
});

// Windows - ground floor
// Living room window
const livingWindowGeometry = new THREE.BoxGeometry(3, 1.2, 0.1);
const livingWindow = new THREE.Mesh(livingWindowGeometry, materials.window);
livingWindow.position.set(2, floorHeight/2 + 0.6, houseDepth/2 - wallThickness/2);
this.model.add(livingWindow);
this.addElementData(livingWindow, 'window', 'Window_Living_Room', {
    'Type': 'Double Glazed',
    'Width': '3000mm',
    'Height': '1200mm',
    'Fire Rating': '0 minutes',
    'Openable': 'Yes',
    'Opening Area': '0.5 sq.m',
    'Level': 'Ground Floor'
});

// Kitchen window
const kitchenWindowGeometry = new THREE.BoxGeometry(2, 1.2, 0.1);
const kitchenWindow = new THREE.Mesh(kitchenWindowGeometry, materials.window);
kitchenWindow.position.set(-3, floorHeight/2 + 0.6, -houseDepth/2 + wallThickness/2);
this.model.add(kitchenWindow);
this.addElementData(kitchenWindow, 'window', 'Window_Kitchen', {
    'Type': 'Double Glazed',
    'Width': '2000mm',
    'Height': '1200mm',
    'Fire Rating': '0 minutes',
    'Openable': 'Yes',
    'Opening Area': '0.4 sq.m',
    'Level': 'Ground Floor'
});

// Windows - first floor
// Bedroom 1 window
const bedroom1WindowGeometry = new THREE.BoxGeometry(1.5, 1.2, 0.1);
const bedroom1Window = new THREE.Mesh(bedroom1WindowGeometry, materials.window);
bedroom1Window.position.set(-3, floorHeight + floorHeight/2 + 0.6, houseDepth/2 - wallThickness/2);
this.model.add(bedroom1Window);
this.addElementData(bedroom1Window, 'window', 'Window_Bedroom_1', {
    'Type': 'Double Glazed',
    'Width': '1500mm',
    'Height': '1200mm',
    'Fire Rating': '0 minutes',
    'Openable': 'Yes',
    'Opening Area': '0.45 sq.m',
    'Level': 'First Floor'
});

// Bedroom 2 window
const bedroom2WindowGeometry = new THREE.BoxGeometry(1.5, 1.2, 0.1);
const bedroom2Window = new THREE.Mesh(bedroom2WindowGeometry, materials.window);
bedroom2Window.position.set(3, floorHeight + floorHeight/2 + 0.6, houseDepth/2 - wallThickness/2);
this.model.add(bedroom2Window);
this.addElementData(bedroom2Window, 'window', 'Window_Bedroom_2', {
    'Type': 'Double Glazed',
    'Width': '1500mm',
    'Height': '1200mm',
    'Fire Rating': '0 minutes',
    'Openable': 'Yes',
    'Opening Area': '0.3 sq.m', // Non-compliant for escape window
    'Level': 'First Floor'
});

// Add a roof
const roofGeometry = new THREE.ConeGeometry(houseWidth/2 * 1.2, 3, 4);
roofGeometry.rotateY(Math.PI/4);
const roof = new THREE.Mesh(roofGeometry, materials.roof);
roof.position.set(0, floorHeight*2 + 1.5, 0);
this.model.add(roof);
this.addElementData(roof, 'roof', 'Roof_Main', {
    'Material': 'Concrete Tiles',
    'Construction': 'Timber Truss',
    'Insulation': 'Mineral Wool',
    'Fire Rating': '30 minutes'
});

// Add stairs
const stairsGroup = new THREE.Group();
stairsGroup.position.set(2, 0, 2);

// Create stairs steps
for (let i = 0; i < 15; i++) {
    const stepGeometry = new THREE.BoxGeometry(1, 0.17, 0.25);
    const step = new THREE.Mesh(stepGeometry, materials.stairs);
    step.position.set(0, i * 0.2, i * -0.25);
    stairsGroup.add(step);
}

this.model.add(stairsGroup);
this.addElementData(stairsGroup, 'stairs', 'Stairs_Main', {
    'Material': 'Timber',
    'Width': '1000mm',
    'Riser': '170mm',
    'Tread': '250mm',
    'Fire Rating': '0 minutes', // Non-compliant
    'Handrail': 'Yes'
});

// Add the model to the scene
this.scene.add(this.model);

// Update model stats
this.modelStats.textContent = `Model: Example Dwelling | Elements: ${Object.keys(this.elements).length}`;

// Reset view to show the entire model
this.resetView();

// Hide no model message
this.noModel.style.display = 'none';

// Hide loading screen
this.hideLoading();
